#include <stdio.h>
#include <stdlib.h> //malloc, free 함수 사용을 위한 헤더 파일


int main()
{
#pragma region 바이트 비트 단위
	//바이트는 컴퓨터에서 데이터를 저장하는 기본 단위이며, 1바이트는 8비트로 구성되어 있습니다.
	//비트는 0 또는 1의 값을 가지며, 바이트는 8개의 비트로 이루어져 있습니다.
	//1바이트 = 8비트
#pragma region MyRegion

#pragma endregion

#pragma endregion

	//int a = 10; //a

	//int* ptr = &a; //ptr

#pragma region 동적 할당
	//프로그램을 실행 중에 필요한 만큼 메모리를 할당하는 작업.
	
	//동적 할당은 실행 시간에 가변적으로 메모리의 크키를 변경시킬 수 있으며,
	//동적으로 메모리의 크기를 할당할 때 바이트 단위로 지정합니다.
	//동적 할당을 위해서는 stdlib.h 헤더 파일을 포함해야 합니다.
	//동적 할당을 위해 malloc 함수를 사용하며, 이 함수는 메모리의 크기를 바이트 단위로 지정합니다.
	//Heap 영역에 메모리를 할당하며, 사용이 끝난 후에는 반드시 free 함수를 사용하여 메모리를 해제해야 합니다.
	//포인트 타입 void*는 어떤 자료형의 포인터도 가리킬 수 있는 포인터 타입입니다.
	//오브젝트를 내 마음대로 할당하고 해제할 수 있는 메모리 공간입니다.

	int* pointer = malloc(4); //4바이트 크기의 메모리를 동적으로 할당합니다.
	
	*pointer = 10; //할당된 메모리에 값을 저장합니다.
	

	printf("pointer가 가리키는 값 : %d\n", *pointer);

	free(pointer); //동적으로 할당된 메모리를 해제합니다.

	pointer = malloc(3 * 4); //3개의 int형 변수를 저장할 수 있는 메모리를 동적으로 할당합니다.=12바이트
	for (int i = 0; i < 3; i++)// for 함수로 연속적으로 메모리를 할당합니다.
	{
		pointer[i] = (i + 1) * 10;
		printf("pointer[%d]의 값 : %d\n", i, pointer[i]);
	}
	free(pointer);
#pragma endregion

#pragma region 추가내용

#pragma region 메모리 파편화
//메모리 파편화는 동적 할당과 해제를 반복하면서 발생하는 메모리의 비효율적인 사용을 의미합니다.
//메모리 파편화는 메모리의 할당과 해제를 반복하면서 발생하는 문제로,
//메모리의 일부가 사용 중이거나 해제되어 있지만, 연속적인 메모리 공간이 부족하여
//새로운 메모리를 할당할 수 없는 상황을 말합니다.
//이로 인해 메모리의 효율적인 사용이 저하되고, 프로그램의 성능에 영향을 미칠 수 있습니다.

#pragma endregion

#pragma region 점진적 가비지 컬렉션
//점진적 가비지 컬렉션은 메모리 관리 기법 중 하나로,
//프로그램이 실행되는 동안 주기적으로 사용하지 않는 메모리를 자동으로 해제하는 방식입니다.
//이 기법은 메모리 파편화를 줄이고, 프로그램의 성능을 향상시키는 데 도움을 줍니다.
#pragma region 점진적 가비지 컬렉션 단점
	//점진적 가비지 컬렉션의 단점은 메모리 해제 작업이 주기적으로 발생하기 때문에,
	//프로그램의 성능에 영향을 미칠 수 있다는 점입니다.

#pragma endregion

#pragma endregion

#pragma region 메모리 플릭
	//메모리 플릭은 메모리 관리 기법 중 하나로,
	//프로그램이 실행되는 동안 메모리를 효율적으로 관리하기 위해
	//메모리의 할당과 해제를 반복하는 방식입니다.
#pragma region 메모리 플릭 단점
	//메모리 플릭의 단점은 메모리의 할당과 해제를 반복하면서 발생하는 메모리 파편화 문제입니다.
	//이로 인해 메모리의 효율적인 사용이 저하되고, 프로그램의 성능에 영향을 미칠 수 있습니다.
#pragma endregion



#pragma endregion

#pragma region 숙제 uaf



#pragma endregion


	
	
	
	return 0;
}