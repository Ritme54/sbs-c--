#include <stdio.h>
#include <stdlib.h> //malloc, free 함수 사용을 위한 헤더 파일


int main()
{
#pragma region 바이트 비트 단위
	//바이트는 컴퓨터에서 데이터를 저장하는 기본 단위이며, 1바이트는 8비트로 구성되어 있습니다.
	//비트는 0 또는 1의 값을 가지며, 바이트는 8개의 비트로 이루어져 있습니다.
	//1바이트 = 8비트
#pragma region MyRegion

#pragma endregion

#pragma endregion

	//int a = 10; //a

	//int* ptr = &a; //ptr

#pragma region 동적 할당
	//프로그램을 실행 중에 필요한 만큼 메모리를 할당하는 작업.

	//동적 할당은 실행 시간에 가변적으로 메모리의 크키를 변경시킬 수 있으며,
	//동적으로 메모리의 크기를 할당할 때 바이트 단위로 지정합니다.
	//동적 할당을 위해서는 stdlib.h 헤더 파일을 포함해야 합니다.
	//동적 할당을 위해 malloc 함수를 사용하며, 이 함수는 메모리의 크기를 바이트 단위로 지정합니다.
	//Heap 영역에 메모리를 할당하며, 사용이 끝난 후에는 반드시 free 함수를 사용하여 메모리를 해제해야 합니다.
	//포인트 타입 void*는 어떤 자료형의 포인터도 가리킬 수 있는 포인터 타입입니다.
	//오브젝트를 내 마음대로 할당하고 해제할 수 있는 메모리 공간입니다.

	//int* pointer = malloc(4); //4바이트 크기의 메모리를 동적으로 할당합니다.
	//
	//*pointer = 10; //할당된 메모리에 값을 저장합니다.
	//
	//
	//printf("pointer가 가리키는 값 : %d\n", *pointer);
	//
	//free(pointer); //동적으로 할당된 메모리를 해제합니다.
	//
	//pointer = malloc(3 * 4); //3개의 int형 변수를 저장할 수 있는 메모리를 동적으로 할당합니다.=12바이트
	//for (int i = 0; i < 3; i++)// for 함수로 연속적으로 메모리를 할당합니다.
	//{
	//	pointer[i] = (i + 1) * 10;
	//	printf("pointer[%d]의 값 : %d\n", i, pointer[i]);
	//}
	//free(pointer);
#pragma endregion

#pragma region 추가내용

#pragma region 메모리 파편화
//메모리 파편화는 동적 할당과 해제를 반복하면서 발생하는 메모리의 비효율적인 사용을 의미합니다.
//메모리 파편화는 메모리의 할당과 해제를 반복하면서 발생하는 문제로,
//메모리의 일부가 사용 중이거나 해제되어 있지만, 연속적인 메모리 공간이 부족하여
//새로운 메모리를 할당할 수 없는 상황을 말합니다.
//이로 인해 메모리의 효율적인 사용이 저하되고, 프로그램의 성능에 영향을 미칠 수 있습니다.

#pragma endregion

#pragma region 점진적 가비지 컬렉션
//점진적 가비지 컬렉션은 메모리 관리 기법 중 하나로,
//프로그램이 실행되는 동안 주기적으로 사용하지 않는 메모리를 자동으로 해제하는 방식입니다.
//이 기법은 메모리 파편화를 줄이고, 프로그램의 성능을 향상시키는 데 도움을 줍니다.
#pragma region 점진적 가비지 컬렉션 단점
	//점진적 가비지 컬렉션의 단점은 메모리 해제 작업이 주기적으로 발생하기 때문에,
	//프로그램의 성능에 영향을 미칠 수 있다는 점입니다.

#pragma endregion

#pragma endregion

#pragma region 메모리 플릭
	//메모리 플릭은 메모리 관리 기법 중 하나로,
	//프로그램이 실행되는 동안 메모리를 효율적으로 관리하기 위해
	//메모리의 할당과 해제를 반복하는 방식입니다.
#pragma region 메모리 플릭 단점
	//메모리 플릭의 단점은 메모리의 할당과 해제를 반복하면서 발생하는 메모리 파편화 문제입니다.
	//이로 인해 메모리의 효율적인 사용이 저하되고, 프로그램의 성능에 영향을 미칠 수 있습니다.
#pragma endregion



#pragma endregion

#pragma region 허상 포인터
	// 이미 해제된 메모리 영역을 가리키는 포인터

	//int* pointer = malloc(4);
	//*pointer = 30;
	//printf("pointer가 가리키는 값 : %d\n", *pointer);
	//free(pointer);
	//
	//pointer = NULL; //허상 포인터를 NULL로 초기화합니다.
	//C#, C++ 등에서 허상 포인터는 이미 해제된 메모리 영역을
	//가리키는 포인터를 의미합니다.
//printf("pointer가 가리키는 값 : %d\n", *pointer); //허상 포인터는 이미 해제된 메모리 영역을 가리키는 포인터로, 이 메모리 영역은 더 이상 유효하지 않습니다.

#pragma endregion


#pragma region (2025.06.03) 숙제 uaf
	//UAF(Use After Free)는 메모리 관리에서 발생할 수 있는 버그 중 하나로,
	//heap 영역에서 동적으로 할당된 메모리를 해제한 후 해제된 메모리를 다시 사용하는 경우를 말합니다.
	//이러한 상황은 프로그램의 예기치 않은 동작을 초래할 수 있으며, 보안 취약점으로 이어질 수 있습니다.
	//C, C++와 같은 언어에서는 메모리 관리를 프로그래머가 직접 수행하기 때문에
	//UAF 버그가 발생할 가능성이 높습니다.

	//위험한 이유
	//해제된 메모리를 다시 사용하면, 해당 메모리 공간에 다른 데이터가 덮어쓰여질 수 있습니다.
	//이로 인해 프로그램이 예기치 않은 동작을 하거나, 보안 취약점이 발생할 수 있습니다.
	//일부 해커들은 UAF 버그를 이용하여 악의적인 코드를 실행하거나, 시스템에 침투할 수 있습니다.

	// 메모리를 제참조한 예시 코드
	//int* exuaf = malloc(sizeof(int)); // int형 변수 크기만큼 메모리를 동적으로 할당합니다.
	//*exuaf = 10;
	//printf("exuaf가 가리키는 값 : %d\n", *exuaf);
	//printf("exuaf의 주소 : %p\n", (void*)exuaf);

	//free(exuaf); //동적으로 할당된 메모리를 해제합니다.

//	printf("exuaf가 가리키는 값 : %d\n", *exuaf); //해제된 메모리를 다시 사용하려고 시도합니다. : UAF 발생

#pragma endregion

	return 0;
}